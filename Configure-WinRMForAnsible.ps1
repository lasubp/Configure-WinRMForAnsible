<#
.SYNOPSIS
  Fully configures a Windows host for Ansible remoting via WinRM,
  even when network profile is set to Public.

.DESCRIPTION
  - Applies persistent WinRM policy registry keys
  - Enables and starts WinRM service
  - Creates listeners (HTTP default, HTTPS optional)
  - Adds firewall rules for all network profiles
  - Configures authentication and TrustedHosts
  - Auto-manages HTTPS certificate lifecycle (create/renew/cleanup) when -UseHTTPS is used
  - Optionally creates a local non-interactive admin service user when -NewUser is used
  - No user interaction required
#>

param(
    [switch]$UseHTTPS,
    [string]$TrustedHosts = "*",
    [int]$Port,
    [switch]$AllowUnencrypted = $true,
    [switch]$SkipNetworkFix = $false,
    [switch]$EnableCredSSP = $false,
    # -------------------------------
    # Service user creation
    # -------------------------------
    [switch]$NewUser,
    [string]$ServiceUserName = "ansible_svc",

    # Optional manual password (simplest, but leaks via command line in many agents)
    [string]$ServiceUserPass,

    # Optional password file (recommended if your agent can stage a file)
    [string]$ServiceUserPassFile
)

# -------------------------------------------------------------------
# Require administrative privileges
# -------------------------------------------------------------------
$IsAdmin = ([Security.Principal.WindowsPrincipal] `
    [Security.Principal.WindowsIdentity]::GetCurrent()
).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)

if (-not $IsAdmin) {
    Write-Host "ERROR: This script must be run as Administrator." -ForegroundColor Red
    Write-Host "Please re-run it in an elevated PowerShell session."
    exit 1
}

# -------------------------------------------------------------------
# Hide user from Windows sign-in screen
# -------------------------------------------------------------------
function Hide-UserFromLogonUI {
    param(
        [Parameter(Mandatory)]
        [string]$UserName
    )

    $regPath = 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList'
    if (-not (Test-Path $regPath)) {
        New-Item -Path $regPath -Force | Out-Null
    }

    # DWORD 0 = hide, 1 = show
    New-ItemProperty -Path $regPath -Name $UserName -PropertyType DWord -Value 0 -Force | Out-Null
}

# -------------------------------------------------------------------
# Create non-interactive local service user (optional)
# -------------------------------------------------------------------
function New-AnsibleServiceUser {
    param(
        [Parameter(Mandatory)]
        [string]$UserName,

        [string]$PlainPassword,

        [string]$PasswordFile
    )

    Write-Host "Ensuring local service user '$UserName' exists..." -ForegroundColor Cyan

    $existing = Get-LocalUser -Name $UserName -ErrorAction SilentlyContinue
    if (-not $existing) {

        # Decide password source (priority: file -> direct param -> autogenerated)
        $plain = $null

        if ($PasswordFile) {
            if (-not (Test-Path $PasswordFile)) {
                throw "Password file not found: $PasswordFile"
            }
            $plain = (Get-Content $PasswordFile -Raw).Trim()

            # best-effort cleanup to reduce secret lifetime
            Remove-Item $PasswordFile -Force -ErrorAction SilentlyContinue
        }
        elseif ($PlainPassword) {
            Write-Warning "ServiceUserPass provided via command line can leak via logs/process args. Prefer -ServiceUserPassFile when possible."
            $plain = $PlainPassword
        }

        if ($plain) {
            $securePassword = ConvertTo-SecureString $plain -AsPlainText -Force
        }
        else {
            Add-Type -AssemblyName System.Web
            $generatedPlain = [System.Web.Security.Membership]::GeneratePassword(32, 6)
            $securePassword = ConvertTo-SecureString $generatedPlain -AsPlainText -Force
        }

        # Create user
        New-LocalUser `
            -Name $UserName `
            -Password $securePassword `
            -Description "Ansible WinRM service account" `
            -PasswordNeverExpires `
            -UserMayNotChangePassword | Out-Null

        Write-Host "User '$UserName' created." -ForegroundColor Green
    }
    else {
        Write-Host "User '$UserName' already exists. Applying hardening..." -ForegroundColor Yellow
    }

    # Add to Administrators (your original line kept)
    Add-LocalGroupMember -Group "Administrators" -Member $UserName -ErrorAction SilentlyContinue

    # Ensure enabled
    Enable-LocalUser -Name $UserName -ErrorAction SilentlyContinue

    # Deny interactive and RDP logon (improved)
    try {
        $lu = Get-LocalUser -Name $UserName -ErrorAction Stop
        $sidToken = "*$($lu.SID.Value)"   # secedit user-rights expect *SID tokens
        $tmp = "$env:TEMP\secpol-ansible.cfg"

        secedit /export /cfg $tmp | Out-Null

        # secedit exports Unicode; read Unicode for correctness
        $content = Get-Content $tmp -Encoding Unicode

        # Ensure keys exist; if not, add them.
        if ($content -notmatch '^SeDenyInteractiveLogonRight') {
            $content += "SeDenyInteractiveLogonRight ="
        }
        if ($content -notmatch '^SeDenyRemoteInteractiveLogonRight') {
            $content += "SeDenyRemoteInteractiveLogonRight ="
        }

        # Append token if missing (Interactive logon)
        $content = $content -replace '^(SeDenyInteractiveLogonRight\s*=\s*)(.*)$', {
            $lhs = $Matches[1]
            $rhs = $Matches[2].Trim()

            $tokens = @()
            if ($rhs) {
                $tokens = $rhs -split "\s*,\s*" | Where-Object { $_ -and $_.Trim() } | ForEach-Object { $_.Trim() }
            }

            $set = @{}
            foreach ($t in $tokens) {
                $nt = $t
                if ($nt -match "^S-1-") { $nt = "*$nt" }   # normalize
                $set[$nt.ToUpperInvariant()] = $true
            }

            if (-not $set.ContainsKey($sidToken.ToUpperInvariant())) {
                $tokens += $sidToken
            }

            "$lhs" + ($tokens -join ",")
        }

        # Append token if missing (Remote interactive / RDP)
        $content = $content -replace '^(SeDenyRemoteInteractiveLogonRight\s*=\s*)(.*)$', {
            $lhs = $Matches[1]
            $rhs = $Matches[2].Trim()

            $tokens = @()
            if ($rhs) {
                $tokens = $rhs -split "\s*,\s*" | Where-Object { $_ -and $_.Trim() } | ForEach-Object { $_.Trim() }
            }

            $set = @{}
            foreach ($t in $tokens) {
                $nt = $t
                if ($nt -match "^S-1-") { $nt = "*$nt" }
                $set[$nt.ToUpperInvariant()] = $true
            }

            if (-not $set.ContainsKey($sidToken.ToUpperInvariant())) {
                $tokens += $sidToken
            }

            "$lhs" + ($tokens -join ",")
        }

        # Write back as Unicode, then apply
        $content | Set-Content $tmp -Encoding Unicode
        secedit /configure /db secedit.sdb /cfg $tmp /areas USER_RIGHTS | Out-Null
    }
    catch {
        Write-Warning "Failed to apply logon restrictions for '$UserName': $($_.Exception.Message)"
    }

    # Hide from Windows logon UI (so it won't appear as a login option)
    try {
        Hide-UserFromLogonUI -UserName $UserName
    }
    catch {
        Write-Warning "Failed to hide '$UserName' from logon UI: $($_.Exception.Message)"
    }

    Write-Host "Service user '$UserName' created and hardened." -ForegroundColor Green
}

if ($NewUser) {
    New-AnsibleServiceUser `
        -UserName $ServiceUserName `
        -PlainPassword $ServiceUserPass `
        -PasswordFile $ServiceUserPassFile
}

# -------------------------------------------------------------------
# Default port assignment
# -------------------------------------------------------------------
if (-not $Port) {
    $Port = if ($UseHTTPS) { 5986 } else { 5985 }
}

Write-Host "=== Configuring WinRM for Ansible ===" -ForegroundColor Cyan

# -------------------------------------------------------------------
# 4. Firewall rules for all profiles (Domain, Private, Public) - ensure rule exists and applies to all profiles
# -------------------------------------------------------------------
function Set-WinRMFirewallRule {
    param (
        [Parameter(Mandatory)]
        [ValidateSet('HTTP','HTTPS')]
        [string]$Transport,

        [Parameter(Mandatory)]
        [int]$Port
    )

    $ruleName = "WinRM-$Transport-$Port"

    $existingRule = Get-NetFirewallRule -Name $ruleName -ErrorAction SilentlyContinue

    if ($existingRule) {
        Write-Host "Firewall rule '$ruleName' already exists. Ensuring correct settings..."
        $existingRule |
            Set-NetFirewallRule -Profile Domain,Private,Public -Direction Inbound -Action Allow |
            Out-Null

        Get-NetFirewallPortFilter -AssociatedNetFirewallRule $existingRule |
            Set-NetFirewallPortFilter -LocalPort $Port -Protocol TCP |
            Out-Null
    }
    else {
        Write-Host "Creating firewall rule '$ruleName'..."
        New-NetFirewallRule `
            -Name $ruleName `
            -DisplayName $ruleName `
            -Description "Allow WinRM $Transport ($Port) for Ansible" `
            -Direction Inbound `
            -Protocol TCP `
            -LocalPort $Port `
            -Action Allow `
            -Profile Domain,Private,Public |
            Out-Null
    }
}

# -------------------------------------------------------------------
# 0. Fix: handle systems with Public network profiles early
# -------------------------------------------------------------------
if (-not $SkipNetworkFix) {
    Write-Host "Checking network profile..."
    $publicNetworks = Get-NetConnectionProfile | Where-Object {$_.NetworkCategory -eq "Public"}
    if ($publicNetworks) {
        foreach ($p in $publicNetworks) {
            Write-Host "Public network detected for '$($p.Name)'. Switching to Private to allow WinRM configuration..." -ForegroundColor Yellow
            try {
                Set-NetConnectionProfile -Name $p.Name -NetworkCategory Private -ErrorAction Stop
            } catch {
                Write-Warning "Failed to change network '$($p.Name)': $_"
            }
        }
        Start-Sleep 2
    }
}

# -------------------------------------------------------------------
# 1. Apply persistent WinRM policy keys
# -------------------------------------------------------------------

function Set-RegistryValue {
    param (
        [Parameter(Mandatory)]
        [string] $Path,

        [Parameter(Mandatory)]
        [string] $Name,

        [Parameter(Mandatory)]
        [object] $Value,

        [Parameter(Mandatory)]
        [Microsoft.Win32.RegistryValueKind] $Type,

        [string] $ChangeLabel
    )

    try {
        if (-not (Test-Path $Path)) {
            New-Item -Path $Path -Force -ErrorAction Stop | Out-Null
        }

        $current = (Get-ItemProperty `
            -Path $Path `
            -Name $Name `
            -ErrorAction SilentlyContinue
        ).$Name

        if ($current -ne $Value) {
            New-ItemProperty `
                -Path $Path `
                -Name $Name `
                -Value $Value `
                -PropertyType $Type `
                -Force `
                -ErrorAction Stop | Out-Null

            if ($ChangeLabel) { $script:RegChanges += $ChangeLabel }
        }
    }
    catch {
        Write-Error "Failed to configure registry value '$Name' at '$Path': $($_.Exception.Message)"
        throw
    }
}

Write-Host "Ensuring WinRM policy registry settings are correctly configured..."

$script:RegChanges = @()

$basePath  = 'HKLM:\Software\Policies\Microsoft\Windows\WinRM\Service'
$winrsPath = 'HKLM:\Software\Policies\Microsoft\Windows\WinRM\Service\WinRS'

# --- WinRM Service policies ---
Set-RegistryValue `
    -Path $basePath `
    -Name 'AllowBasic' `
    -Value 1 `
    -Type DWord `
    -ChangeLabel 'AllowBasic'

Set-RegistryValue `
    -Path $basePath `
    -Name 'AllowAutoConfig' `
    -Value 1 `
    -Type DWord `
    -ChangeLabel 'AllowAutoConfig'

if ($AllowUnencrypted) {
    Set-RegistryValue `
        -Path $basePath `
        -Name 'AllowUnencryptedTraffic' `
        -Value 1 `
        -Type DWord `
        -ChangeLabel 'AllowUnencryptedTraffic'
}

# --- WinRS policies ---
Set-RegistryValue `
    -Path $winrsPath `
    -Name 'AllowRemoteShellAccess' `
    -Value 1 `
    -Type DWord `
    -ChangeLabel 'AllowRemoteShellAccess'

# --- UAC local token filter ---
Set-RegistryValue `
    -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System' `
    -Name 'LocalAccountTokenFilterPolicy' `
    -Value 1 `
    -Type DWord `
    -ChangeLabel 'LocalAccountTokenFilterPolicy'

# --- Output ---
if ($RegChanges.Count -eq 0) {
    Write-Host "WinRM policy registry settings already correct"
}
else {
    Write-Host "WinRM policy registry updated (" + ($RegChanges -join ', ') + ")"
}

# -------------------------------------------------------------------
# Optimize certificate checks for offline/local networks (machine-wide)
# Avoids slow CRL/OCSP online checks for self-signed certs (reduces boot delay)
# -------------------------------------------------------------------
try {
    Write-Host "Applying machine-wide WinTrust optimization to reduce online CRL checks..."
    $wk = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WinTrust\Trust Providers\Software Publishing"
    if (-not (Test-Path $wk)) { New-Item -Path $wk -Force | Out-Null }
    # Value 146944 reduces strict online revocation checks (helps booting offline)
    Set-ItemProperty -Path $wk -Name "State" -Value 146944 -Type DWord -Force
} catch {
    Write-Warning "Could not apply WinTrust optimization: $_"
}

# -------------------------------------------------------------------
# 2. Enable PS Remoting / WinRM service
# -------------------------------------------------------------------
Write-Host "Ensuring WinRM service is correctly configured..."

try {
    $changes = @()

    # Always enforce dependencies (cannot be reliably detected)
    sc.exe config winrm depend= http/cryptsvc | Out-Null

    $svc = Get-CimInstance Win32_Service -Filter "Name='WinRM'" -ErrorAction Stop

    # --- Startup type (Delayed Auto) ---
    if ($svc.StartMode -ne 'Auto' -or -not $svc.DelayedAutoStart) {
        sc.exe config winrm start= delayed-auto | Out-Null
        $changes += 'startup type'
    }

    # --- Running state ---
    if ($svc.State -ne 'Running') {
        Start-Service WinRM -ErrorAction Stop
        $changes += 'service started'
    }

    # --- Output ---
    if ($changes.Count -eq 0) {
        Write-Host "WinRM already configured and running"
    }
    else {
        Write-Host "WinRM updated (" + ($changes -join ', ') + ")"
    }
}
catch {
    Write-Warning "WinRM configuration failed: $($_.Exception.Message)"
}

# -------------------------------------------------------------------
# 3. Create listener(s) (HTTPS optional) and manage HTTPS cert lifecycle
# -------------------------------------------------------------------
if ($UseHTTPS) {
    Write-Host "Configuring HTTPS listener on port $Port..."

        # --- Self-healing cleanup for stale HTTPS listeners or mismatched certs ---
        Write-Host "Ensuring WinRM HTTPS listener and certificate are valid..." -ForegroundColor Cyan

        $hostname  = $env:COMPUTERNAME
        $now       = Get-Date

        # Get primary IPv4 (stable, non-APIPA)
        $primaryIP = Get-NetIPAddress -AddressFamily IPv4 |
            Where-Object {
                $_.IPAddress -notmatch '^169\.254' -and
                $_.IPAddress -ne '127.0.0.1' -and
                $_.PrefixOrigin -ne 'WellKnown'
            } |
            Select-Object -ExpandProperty IPAddress -First 1

        # ------------------------------------------------------------
        # 1. Read existing HTTPS listener (do NOT delete blindly)
        # ------------------------------------------------------------
        $listenerText = winrm get winrm/config/Listener?Address=*+Transport=HTTPS 2>$null
        $currentThumb = $null

        $thumbLine = $listenerText | Select-String 'CertificateThumbprint'
        if ($thumbLine -and $thumbLine.Line -match '=\s*([A-F0-9]{40})') {
            $currentThumb = $Matches[1]
        }
        # ------------------------------------------------------------
        # 2. Try to reuse an existing valid certificate
        # ------------------------------------------------------------
        $cert = $null

        if ($currentThumb) {
            $cert = Get-ChildItem "Cert:\LocalMachine\My\$currentThumb" -ErrorAction SilentlyContinue
        }

        if (-not $cert) {
            $cert = Get-ChildItem Cert:\LocalMachine\My |
                Where-Object {
                    $_.FriendlyName -eq 'WinRM HTTPS for Ansible' -and
                    $_.NotAfter -gt $now
                } |
                Sort-Object NotAfter -Descending |
                Select-Object -First 1
        }

        # ------------------------------------------------------------
        # 3. Validate cert hostname / SAN
        # ------------------------------------------------------------
        $certValid = $false

        if ($cert) {
            $certValid = $true

            if ($cert.Subject -notmatch [regex]::Escape($hostname) -and
                ($primaryIP -and $cert.Subject -notmatch [regex]::Escape($primaryIP))) {
                $certValid = $false
            }

            try {
                $san = ($cert.Extensions |
                    Where-Object { $_.Oid.FriendlyName -eq 'Subject Alternative Name' }
                ).Format($false)

                if ($san -and (
                    $san -match [regex]::Escape($hostname) -or
                    ($primaryIP -and $san -match [regex]::Escape($primaryIP))
                )) {
                    $certValid = $true
                }
            } catch {}
        }

        # ------------------------------------------------------------
        # 4. Create cert ONLY if required
        # ------------------------------------------------------------
        if (-not $certValid) {
            Write-Host "Creating new self-signed certificate for WinRM HTTPS..." -ForegroundColor Yellow

            $dnsNames = @($hostname)

            $cert = New-SelfSignedCertificate `
                -DnsName $dnsNames `
                -CertStoreLocation 'Cert:\LocalMachine\My' `
                -FriendlyName 'WinRM HTTPS for Ansible' `
                -NotAfter ($now.AddYears(5))
        }

        # ------------------------------------------------------------
        # 5. Ensure listener exists and is bound to correct cert
        # ------------------------------------------------------------
        $needsListener = $true

        if ($currentThumb -and $cert.Thumbprint -eq $currentThumb) {
            $needsListener = $false
        }

        if ($needsListener) {
            Write-Host "Binding certificate to WinRM HTTPS listener..." -ForegroundColor Yellow

            try {
                winrm delete winrm/config/Listener?Address=*+Transport=HTTPS 2>$null | Out-Null
            } catch {}

            $listenerHostname = $hostname

            winrm create winrm/config/Listener?Address=*+Transport=HTTPS `
                "@{Hostname=`"$listenerHostname`";CertificateThumbprint=`"$($cert.Thumbprint)`";Port=`"$Port`"}" |
            Out-Null

        }

        # ------------------------------------------------------------
        # 6. Safe cleanup: remove expired or truly unused WinRM certs
        # ------------------------------------------------------------
        try {
            Write-Host "Performing WinRM certificate cleanup..." -ForegroundColor Cyan

            if (-not $cert -or -not $cert.Thumbprint) {
                Write-Warning "Active WinRM certificate not identified; skipping cleanup to avoid accidental removal."
                return
            }

            $boundThumbs = @($cert.Thumbprint)
            $removed     = @()

            Get-ChildItem Cert:\LocalMachine\My -ErrorAction Stop |
                Where-Object {
                    $_.FriendlyName -eq 'WinRM HTTPS for Ansible' -and
                    (
                        $_.NotAfter -lt $now -or
                        $_.Thumbprint -notin $boundThumbs
                    )
                } |
                ForEach-Object {
                    try {
                        Write-Host "Removing stale WinRM certificate: $($_.Thumbprint)" -ForegroundColor DarkGray
                        Remove-Item $_.PSPath -Force -ErrorAction Stop
                        $removed += $_.Thumbprint
                    } catch {
                        Write-Warning "Failed to remove certificate $($_.Thumbprint): $($_.Exception.Message)"
                    }
                }

            if ($removed.Count -eq 0) {
                Write-Host "No stale or expired WinRM certificates found." -ForegroundColor Green
            } else {
                Write-Host "Removed WinRM certificates: $($removed -join ', ')" -ForegroundColor Yellow
            }

        } catch {
            Write-Warning "WinRM certificate cleanup encountered an issue and was skipped: $($_.Exception.Message)"
        }

        Write-Host "WinRM HTTPS listener and certificate are valid." -ForegroundColor Green

} else {
    Write-Host "Configuring HTTP listener on port $Port..."
    $httpListener = winrm enumerate winrm/config/listener 2>$null | Select-String "Transport = HTTP"
    if (-not $httpListener) {
        & winrm create winrm/config/Listener?Address=*+Transport=HTTP "@{Port=`"$Port`"}" | Out-Null
    } else {
        Write-Host "HTTP listener already exists."
    }

    # Add HTTP firewall rule idempotently
    Set-WinRMFirewallRule -Transport HTTP -Port $Port

}

# -------------------------------------------------------------------
# 5. Configure WinRM authentication & transport settings
# -------------------------------------------------------------------
Write-Host "Ensuring WinRM authentication settings are correctly configured..."

try {
    $changes = @()

    # Helper: set WSMan value only if different
    function Set-WSManValue {
        param (
            [Parameter(Mandatory)]
            [string] $Path,

            [Parameter(Mandatory)]
            [bool] $DesiredValue,

            [string] $ChangeLabel
        )

        $current = Get-Item $Path -ErrorAction Stop

        if ([bool]$current.Value -ne $DesiredValue) {
            Set-Item $Path -Value $DesiredValue -ErrorAction Stop
            if ($ChangeLabel) { $changes += $ChangeLabel }
        }
    }

    # --- Authentication mechanisms ---
    Set-WSManValue 'WSMan:\localhost\Service\Auth\Basic'     $true 'Basic auth'
    Set-WSManValue 'WSMan:\localhost\Service\Auth\Negotiate' $true 'Negotiate auth'

    if ($EnableCredSSP) {
        Enable-WSManCredSSP -Role Server -Force | Out-Null
        Set-WSManValue 'WSMan:\localhost\Service\Auth\CredSSP' $true 'CredSSP'
    }
    else {
        Set-WSManValue 'WSMan:\localhost\Service\Auth\CredSSP' $false 'CredSSP disabled'
    }

    if ($AllowUnencrypted -and -not $UseHTTPS) {
        try {
            Set-WSManValue 'WSMan:\localhost\Service\AllowUnencrypted' $true 'AllowUnencrypted'
        }
        catch {
            Write-Warning "Could not set AllowUnencrypted via WSMan provider; continuing"
        }
    }

    # --- Output ---
    if ($changes.Count -eq 0) {
        Write-Host "WinRM authentication settings already correct"
    }
    else {
        Write-Host "WinRM authentication updated (" + ($changes -join ', ') + ")"
    }
}
catch {
    Write-Warning "WinRM authentication configuration failed: $($_.Exception.Message)"
}


# -------------------------------------------------------------------
# 6. TrustedHosts configuration
# -------------------------------------------------------------------
if ($TrustedHosts) {
    Write-Host "Setting TrustedHosts to '$TrustedHosts'..."
    Set-Item WSMan:\localhost\Client\TrustedHosts -Value $TrustedHosts -Force
}

# -------------------------------------------------------------------
# 7. Restart WinRM and confirm
# -------------------------------------------------------------------
Restart-Service WinRM -Force

Write-Host "=== WinRM configuration complete ($(if ($UseHTTPS) {'HTTPS'} else {'HTTP'})) (Public network compatible) ===" -ForegroundColor Green
Write-Host "Port: $Port"
Write-Host "TrustedHosts: $TrustedHosts"
Write-Host "Unencrypted: $AllowUnencrypted"
Write-Host "Auth: Basic=$true, Negotiate=$true, CredSSP=$EnableCredSSP"
if ($UseHTTPS) {
    $curThumb = (winrm enumerate winrm/config/listener 2>$null | Select-String "CertificateThumbprint" | ForEach-Object { ($_ -split '=')[-1].Trim() }) | Select-Object -First 1
    Write-Host "Certificate Thumbprint: $curThumb"
}
Write-Host "`nNow you can test from Ansible:"
Write-Host "  ansible windows -i inventory.ini -m ansible.windows.win_ping" -ForegroundColor Yellow
